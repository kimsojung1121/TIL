#### 새로운 할인 정책 개발

- `@DisplayName` 어노테이션
- static import
```
import static org.assertj.core.api.Assertions.*;
```

#### 새로운 할인 정책 적용과 문제점
현재 할인 정책을 변경하려면, OrderServiceImpl 코드를 고쳐야 한다.
- 객체지향 설계 원칙 OCP, DIP 위반
- 코드를 변경할 때(확장할 때) 클라이언트 코드에 영향을 준다
- 클라이언트 코드에서 추상 인터페이스에만 의존하는 것이 아닌, 구체화한 클래스에도 의존하고 있기 때문임.
- => 추상에만 의존할 수 있도록 의존관계를 변경해야 한다. 

#### 관심사의 분리
클라이언트 코드는 구체적인 선택까지 담당하지 않는다.
- AppConfig
  - 애플리케이션의 전체 동작 방식을 구성하기 위해, 구현 객체를 생성하고, 연결하는 책임을 가지는 별도의 설정 클래스 생성
  - **생성자 주입 ?**

---
### 의존성 주입
> 20220711 추가 작성

**프로그래머는 "추상화에 의존해야지, 구체화에 의존하면 안 된다."의존성 주입은 이 원칙을 따르는 방법 중 하나다.**

- 의존성 주입 방법은 생성자 주입, 수정자 주입, 필드 주입 세 가지가 있다.
- 필드 주입은 방법이 간편해서 실무에서 자주 쓰인다.
- 스프링에서는 필드 주입보다 생성자 주입 방식을 권장한다. (이유는 밑에서)

1. 생성자 주입(Constructor Injection)
2. 수정자 주입(Setter 주입, Setter Injection)
3. 필드 주입(Field Injection)

#### 1. 생성자 주입
- 생성자를 통해 의존 관계를 주입하는 방식이다.
- 생성자가 1개인 경우에는 `@Autowired` 어노테이션 생략 가능하다.(다른 주입 방식은 생략 불가)
  - 롬복(Lombok)의 `@RequiredArgsConstructor` 어노테이션을 사용하면 더 간략하게 작성할 수 있다.
  - 롬복(Lombok)이란? 
    - 어노테이션 기반으로 코드를 자동완성해주는 라이브러리
    - 코드 자동 생성을 통해 생산성 향상
    - 코드 다이어트를 통한 가독성 및 유지보수성 향상
    - `@Getter`, `@Setter`, `@RequiredArgsConstructor` 등
  - `@RequiredArgsConstructor` 어노테이션
    - `final`로 선언되거나 `@NotNull`로 선언된 필드에 대해 생성자를 자동 생성해 준다.
- **필드를 `final`로 선언 가능하다.**
  - 객체의 불변성을 보장한다.

#### 2. 수정자 주입
- 필드값을 변경하는 Setter를 통해서 의존 관계를 주입하는 방식이다.
- 주입받는 객체가 변경 가능성이 있는 경우 사용한다.(극히 드묾)

#### 3. 필드 주입
- 필드에 바로 의존관계를 주입하는 방식이다.
- 필드에 `@Autowired` 어노테이션만 사용하면 되는 간편한 방식이라 과거에는 많이 사용되었으나, 여러 문제로 현재는 생성자 주입을 권장하고 필드 주입은 지양하고 있다.
- 필드 주입의 문제점?
  - 단일 책임의 원칙 위반
    - 코드가 간결해 의존성 주입이 쉽다.
    - 따라서 하나의 클래스에 과도하게 역할이 몰려 있어도 알아채기 쉽지 않다.
  - 필드에 `final` 선언 불가 - 객체가 변할 수 있음
  - 순환 참조 문제 발생 가능성
    - 순환 참조란? A가 B를 참조하는데, B가 A를 참조하는 것.
    - 스프링부트 2.6부터는 순환 참조가 기본적으로 허용되지 않도록 변경되었기 때문에 2.6 이전 버전까지의 문제이다.
  
#### 생성자 주입을 권장하는 이유
- `final` 선언 가능
  - 위에 생성자 주입의 특징, 필드 주입의 문제점에서도 말했듯이 필드를 `final`로 선언하여 불변성을 보장할 수 있다.
  - 또한 컴파일 시점에서 누락된 의존성을 확인할 수 있다.
- 테스트 코드 작성의 용이성
  - 테스트 코드는 프레임워크에 의존하지 않고 순수 자바로 작성 가능한 것이 좋다.
  - 생성자 주입 외의 의존성 주입 방식은 순수 자바로 작성 불가하다.
- 순환 참조 문제 방지
  - 객체를 생성하는 과정에서 순환 참조를 발견하고 이를 방지할 수 있다.

> 참고 - [[Spring] 다양한 의존성 주입 방법과 생성자 주입을 사용해야 하는 이유 - (2/2)](https://mangkyu.tistory.com/125)
