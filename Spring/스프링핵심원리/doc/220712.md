### AppConfig 리펙터링
현재 `AppConfig`에서는 중복이 있고, 역할에 따른 구현이 한눈에 보이지 않는다.

- 단축키 `Ctrl` + `Alt` + `M` : 메소드 분리(추출), 드래그 한 부분을 새로운 메소드로 빼낸다.
- `MemoryMemberRepository()` 객체 생성 부분을 메소드로 생성해서 중복을 제거했다 <br>
=> `MemoryMemberRepository()`를 다른 구현 클래스로 변경할 때 <br>
기존 중복 코드에서는 여러번 변경할 것을, 중복 제거 후에는 한 번만 변경하면 된다. (유지보수의 효율성) 
- 같은 방법으로 `FixDiscountPolicy()` 객체 생성 부분을 메소드로 생성. <br>
=> **역할과** (`MemberService`, `OrderService`) **역할에 따른 구현**(`MemoryMemberRepository`, `DiscountPolicy`)이 한눈에 들어와 
`AppConfig` 전체 구성을 빠르게 파악할 수 있게 됐다.


### 새로운 구조와 할인 정책 적용
정액할인을 %할인 정책으로 변경한다.
![image](https://user-images.githubusercontent.com/39394592/178497764-5717290a-0bd8-4aa9-b371-1773149701d7.png)

- `FixDiscountPolicy` 구현체에서 `RateDiscountPolicy`로 변경하는 것으로 설계 완료.
- **클라이언트 코드(사용 영역의 코드)는 변경되지 않는다.**

### 전체 흐름 정리
1. 새로운 할인 정책 개발과 문제점
    - 개발하는 것에는 문제가 없었으나, 애플리케이션에 새로운 정책을 반영하려고 하니 **DIP 위반** 문제가 발생했다. <br>
이유는 클라이언트 코드에서 추상 인터페이스만 의존하는 게 아닌 구체 클래스까지 의존하고 있었기 때문.
2. 관심사의 분리
    - 애플리케이션의 전체 동작 방식을 구성(config)하기 위해, `AppConfig`를 생성해서 **구현 객체 생성 및 연결의 책임**을 부여한다.
    <br> `AppConfig`로 역할을 분리하게 되어, 클라이언트 객체는 실행에만 집중한다. (**권한이 줄어들고 책임은 명확해짐**)
    > SRP 단일 책임 원칙 : 한 클래스는 하나의 책임만 가져야 한다.
3. AppConfig 리펙터링
    - 역할과 구현을 분리하고, 중복을 제거한다.
4. 새로운 구조와 할인 정책 적용
    - **관심사의 분리로 인해, 할인 정책을 변경하여도 사용 영역(클라이언트)의 변경 없이 구성 영역의 변경만으로 기능의 확장이 가능하게 되었다.**

### 좋은 객체 지향 설계의 5가지 원칙의 적용

