# 스레드(Thread)


: 프로세스에서 명령을 실행하는 작업 단위 >> 프로그램 흐름

### 단일 스레드 프로그램

- JVM에 의해 생성된 스레드(main Thread)를 이용하여 main() 메소드의 명령 실행
- main() 메소드가 종료되면 자동으로 스레드 소멸 - 프로그램 종료

 

##### [실습] [SigleThread.java](https://github.com/swanstoz/TIL/blob/master/JAVA/thread/SingleThread.java), [SigleThreadApp.java](https://github.com/swanstoz/TIL/blob/master/JAVA/thread/SigleThreadApp.java)

- 단일 스레드 프로그램(프로그램 흐름 확인)

    - SigleThreadApp.java 실행시 JVM이 main() 메소드를 호출하기 위해 자동으로 main 스레드 생성
    - main() 메소드가 종료되면 main 스레드가 자동 소멸 - 프로그램 종료

    - 인스턴스 메소드 호출하면 스레드가 이동되어 메소드의 명령 실행
    ```java
    new SingleThread().display();
    ```
    - 호출 메소드가 실행 후 스레드 복귀(return)
    - ##### 출력 결과를 확인하면 하나의 스레드(main 스레드)만을 통해 명령이 실행되는 것을 확인할 수 있음
 
---

### 다중 스레드 프로그램 
- 개발자가 직접 스레드를 생성하여 여러 명령이 동시에 실행되도록 프로그램 작성
- 프로그램의 모든 스레드가 소멸되면 프로그램 종료
- GUI 프로그램, 웹 프로그램 등은 다중 스레드 프로그램으로 작성

 

### 다중 스레드 프로그램 작성 방법

: 개발자가 스레드를 생성하여 명령 실행
##### 1. Thread 클래스를 상속 받아 스레드 생성하는 방법
##### 2. Runnable 인터페이스를 상속 받아 스레드 생성하는 방법
 
---
 
### Thread 클래스를 상속 받아 스레드 생성하는 방법 

##### [실습] [MultiThreadApp.java](https://github.com/swanstoz/TIL/blob/master/JAVA/thread/MultiThreadApp.java), [MultiThreadOne](https://github.com/swanstoz/TIL/blob/master/JAVA/thread/MultiThreadOne.java)

1. Thread 클래스를 상속 받는 자식클래스 작성
  ```java
  public class MultiThreadOne extends Thread {
    
  }//end class
  ```
3. 자식클래스에서 run() 메소드를 오버라이드 선언 
      - 개발자가 생성한 스레드로 실행될 명령을 작성하는 메소드
  ```java
  public class MultiThreadOne extends Thread {
	@Override
	public void run() {
		//새로운 스레드로 실행될 명령 작성
		//대문자 A부터 Z까지 출력
		for(char i='A';i<='Z';i++) {
			System.out.print(i);
		}
  }//end of class
  ```
4. 자식클래스를 이용하여 인스턴스 생성 - Thread 인스턴스 자동 생성
      - 자식클래스로 인스턴스를 생성할 경우 부모클래스의 인스턴스(Thread 인스턴스)가 먼저 생성  
  ```java
  MultiThreadOne thread = new MultiThreadOne();
  ```
5. Thread 인스턴스로 start() 메소드 호출 
      - Thread 인스턴스로 스레드를 생성하여 run() 메소드의 명령 실행
  ```java
  thread.start();
  ```
  > Thread 인스턴스로 start() 메소드 외 호출할 메소드가 없는 경우 참조변수 없이 메소드 호출이 가능하다
  > ```javaa
  > new MultiThreadOne().start(); 
  > ```
  
  - 스레드 인스턴스로 하나의 스레드만 생성 가능
  ```java
  new MultiThreadOne().start();
  new MultiThreadOne().start();
  ```
 
---

### Runnable 인터페이스를 상속 받아 스레드 생성하는 방법

##### [실습] [MultiThreadApp.java](https://github.com/swanstoz/TIL/blob/master/JAVA/thread/MultiThreadApp.java), [MultiThreadTwo.java](https://github.com/swanstoz/TIL/blob/master/JAVA/thread/MultiThreadTwo.java)

- Thread 클래스를 상속 받지 못할 경우 사용 - 단일상속의 문제점
1. Runnable 인터페이스를 상속 받는 자식클래스 작성
  ```java
  public class MultiThreadTwo implements Runnable {
    
  }//end class
  ```
  > 오버라이드 선언하지 않으면 에러 발생
3. 자식클래스에서 run() 메소드를 오버라이드 선언
  ```java
  public class MultiThreadTwo implements Runnable {

    @Override
    public void run() {
      //소문자 A부터 Z까지 출력
      for(char i='a';i<='z';i++) {
        System.out.print(i);
      }//end of for
    }//end of run()
  }//end of class
  ```
5. Thread 클래스를 이용하여 Thread 인스턴스를 생성 - Thread 인스턴스 직접 생성
      - Runnable 인터페이스를 상속 받는 자식클래스의 인스턴스를 전달받는 생성자 이용
  ```java
  Thread thread=new Thread(multiThreadTwo);
  ```
6. 스레드 인스턴스로 start() 메소드 호출
  ```java
  thread.start();
  ```
  > 다음과 같이 인스턴스 생성과 start() 메소드 호출 동시에 작성 가능
  > ```java
  > new Thread(new MultiThreadTwo()).start();
  > ```
 
---

- Thread 클래스의 메소드
    - start() : 스레드를 생성하여 run() 메소드에 작성된 명령을 실행하는 메소드  
    - stop() : 스레드를 강제로 소멸시키는 메소드 >> Deprecated
    - suspend() : 스레드를 일시 중지 시키는 메소드 >> Deprecated - java.lang.Object 클래스의 wait() 메소드  
    - resume() : suspend() 메소드로 중지된 스레드를 실행하는 메소드 >> Deprecated - java.lang.Object 클래스의 notify() 메소드
    - sleep() : 원하는 시간(ms) 동안 스레드를 일시 중지

 

- 스레드 우선순위(PRIORITY) 변경 : 우선순위 기본값 >> 5(Thread.NORM_PRIORITY)     
    >> Thread.setPriority(int newPriority) 메소드 호출
    >> newPriority : 1(Thread.MIN_PRIORITY) ~ 10(Thread.MAX_PRIORITY)

 

[실습]PriorityOne.java

public class PriorityOne extends Thread {
	@Override
	public void run() {
		// TODO Auto-generated method stub
		while(true) {
			System.out.print("A");
		}
	}
}
[실습]PriorityTwo.java

public class PriorityTwo extends Thread {
	@Override
	public void run() {
		// TODO Auto-generated method stub
		while(true) {
			System.out.print("B");
		}
	}
}
[실습]PriorityApp.java

public class PriorityApp {
	public static void main(String[] args) {
		PriorityOne one=new PriorityOne();
		PriorityTwo two=new PriorityTwo();
		
		one.setPriority(Thread.MIN_PRIORITY);
		two.setPriority(Thread.MAX_PRIORITY);
		
		one.start();
		two.start();
	}
}
- 다중 스레드 프로그램의 문제점
    >> 동일한 run() 메소드의 명령을 실행하는 다수의 스레드에서 인스턴스 
       필드값(공유값) 변경 관련 동일 메소드 호출시 잘못된 결과 제공
       
- 다중 스레드 프로그램의 문제점 해결방법
    >> 스레드 동기화 : 스레드의 메소드 호출에 대한 스레드 일시 중지 기능
    >> 다수의 스레드가 인스턴스 필드값 변경 관련 동일 메소드를 호출할 경우
       먼저 호출 요청한 스레드에 대한 처리 결과가 제공될 때까지 다른 스레드의
       메소드 호출에 대한 명령 처리를 일시 중지(Method Lock) 
       
- 스레드 동기화 방법
    1) 인스턴스 필드값 변경 메소드에 대한 동기화 처리 - 동기화 메소드
    
       형식) 접근지정자 synchronized 반환형 메소드명(파라메터,..) {
                  인스턴스 필드값 변경 명령;
                  ...
             }
    
    2) 인스턴스 필드값 변경 메소드 호출하는 명령에 대한 동기화 처리

       >> 동기화 메소드로 변경하지 못할 경우 사용    
    
       형식) synchronized(인스턴스) {
                 인스턴스 필드값 변경 메소드 호출 명령;
                 ... 
             }

 

[실습]Account.java

//은행계좌정보(잔액)를 저장하기 위한 클래스
public class Account {
	private int balance;

//생성자
	public Account() {
		// TODO Auto-generated constructor stub
	}

	public Account(int balance) {
		super();
		this.balance = balance;
	}

//setter. getter
	public int getBalance() {
		return balance;
	}

	public void setBalance(int balance) {
		this.balance = balance;
	}
	
	//입금 처리 메소드 - 입금자와 입금액을 전달받아 처리
	//synchronized : 스레드에 대한 동기화 처리 메소드로 설정하기 위한 지정자
	public synchronized void deposit(String name, int amount) {
		balance+=amount;
		System.out.println("[입금]"+name+"님이 "+amount+"원 입금하여 잔액은 "+balance+"원입니다.");
	}
	
	//출금 처리 메소드 - 출금자와 출금액을 전달받아 처리
	public void withDraw(String name, int amount) {
		if(balance<amount) {
			System.out.println("[에러]"+name+"님, 잔액이 "+balance+"원 남아 "+amount+"원을 출금할 수 없습니다.");
			return;
		}
		balance-=amount;
		System.out.println("[출금]"+name+"님이 "+amount+"원 출금하여 잔액은 "+balance+"원입니다.");		
	}

}
[실습]AccountUser.java

//은행계좌의 사용자 정보(은행계좌 정보, 사용자명)를 저장하기 위한 클래스
public class AccountUser extends Thread {
	private Account account;//은행계좌정보 - 포함
	private String userName;//사용자명

//생성자
	public AccountUser() {
		// TODO Auto-generated constructor stub
	}

	public AccountUser(Account account, String userName) {
		super();
		this.account = account;
		this.userName = userName;
	}

//setter,getter
	public Account getAccount() {
		return account;
	}

	public void setAccount(Account account) {
		this.account = account;
	}

	public String getUserName() {
		return userName;
	}

	public void setUserName(String userName) {
		this.userName = userName;
	}
	
	@Override
	public void run() {
		//다수의 스레드가 run() 메소드의 명령을 동시에 실행할 경우 동일 인스턴스의 메소드를
		//호출하여 필드값을 변경하여 처리할 경우 잘못된 결과 발생
		// => 스레드 동기화를 이용하여 스레드의 인스턴스 메소드 실행 순서를 자동 설정
		//스레드 동기화(Thread Synchronized) : 스레드의 메소드 요청에 대한 처리가 종료될 때까지
		//다른 스레드의 메소드 호출을 방지(lock)하도록 스레드를 일시 중지하는 기능
		// => 메소드를 동기화 처리하는 방법 - 동기화 메소드(Synchronized Method)로 선언하여 호출
//		account.deposit(userName, 5000);
		
		//메소드를 동기화 처리하는 방법 - 동기화 영역(Synchronized Block)에서 메소드 호출
		// => 인스턴스를 전달받아 인스턴스의 모든 메소드를 동기화 처리하여 호출 - 권장하지 않음
		synchronized(account) {
			account.withDraw(userName, 2000);
		}
	}
}
[실습]AccountUserApp.java

public class AccountUserApp {
	public static void main(String[] args) {
		Account account=new Account(10000);
		
		/*
		//단일 스레드를 이용하여 사용자의 입금 처리 - 순차적 처리
		AccountUser[] users=new AccountUser[3];
		users[0]=new AccountUser(account, "홍길동");
		users[1]=new AccountUser(account, "임꺽정");
		users[2]=new AccountUser(account, "전우치");
		
		for(AccountUser user:users) {
			user.getAccount().deposit(user.getUserName(), 5000);
		}
		*/
		
		
		//다중 스레드를 이용하여 사용자의 입금(출력) 처리
		new AccountUser(account, "홍길동").start();
		new AccountUser(account, "임꺽정").start();
		new AccountUser(account, "전우치").start();
	}//end of main
}//end of class
