# 1과목 데이터 모델링의 이해
## 1장 데이터 모델링의 이해

### 데이터 모델링이란
- 현실세계를 일정한 형식에 맞춰 표현하는 추상화의 의미를 가진다
- 단순화, 정확화
- 단순 시스템 구현만을 위한 것이 아니라, 시스템 구현을 포함한 업무분석 및 업무형상화의 목적이 있다.

### 데이터 모델링의 중요성 및 유의점
1. 중복 
- 같은 시간에 같은 데이터 제공
> 데이터 모델은 같은 데이터를 사용하는 사람, 시간 그리고 장소를 파악하는데 도움을 줌으로써 데이터베이스가 여러 장소에 같은 정보를 저장하는 잘못을 하지 않도록 한다.
2. 비유연성
- 사소한 업무변화에 데이터 모델이 수시로 변경되지 않아야 함
- 데이터 정의를 사용
- 프로세스와 분리
> 데이터 모델을 어떻게 설계했느냐에 따라 사소한 업무변화에도 데이터 모델이 수시로 변경됨으로써 유지보수의 어려움을 가중시킬 수 있다.
> 데이터의 정의를 데이터의 사용 프로세스와 분리함으로써 데이터 모델링은 데이터 혹은 프로세스의 작은 변화가 애플리케이션과 데이터베이스에 중대한 변화를 일으킬 수 있는 가능성을 줄인다.
3. 비일관성
- 데이터 간 상호 연관 관계에 대해 명확하게 정의해야 함
> 데이터의 중복이 없더라도 비일관성은 발생할 수 있는데, 예를 들면 신용 상태에 대한 갱신 없이 고객의 납부 이력 정보를 갱신하는 경우이다. 개발자가 서로 연관된 다른 데이터와 모순된다는 고려 없이 일련의 데이터를 수정할 수 있기 때문에 이와 같은 문제가 발생할 수 있다. 데이터 모델링을 할 때 데이터와 데이터 간의 상호 연관 관계에 대해 명확하게 정의한다면 이러한 위험을 사전에 예방하는데 도움을 줄 수 있다. 
> **사용자가 처리하는 프로세스 혹은 이와 관련된 프로그램과 테이블의 연계성을 높이는 것은 데이터 모델이 업무 변경에 대해 취약하게 만드는 단점에 해당한다.**

### 데이터 모델링
개념적, 논리적, 물리적 데이터 모델링
1. 개념적 데이터 모델링
- 추상화 수준이 높고 **업무중심적**이고 포괄적인 수준의 모델링
- 전사적 데이터 모델링
2. 논리적 데이터 모델링
- 시스템으로 구축하고자 하는 업무에 대해 Key, 속성, 관계 등을 정확하게 표현
- **재사용성이 높음**
3. 물리적 데이터 모델링
- 실제로 데이터베이스에 이식할 수 있도록 성능, 저장 등 물리적인 성격을 고려하여 설계
<br> 개념적 데이터 모델링 → 논리적 데이터 모델링 → 물리적 데이터 모델링으로 갈수록 구체적이어진다

### 데이터 독립성 요소
외부, 개념, 내부 스키마
1. 외부 스키마
- 개개인의 사용자가 보는 개인적 DB 스키마
- DB의 개개 사용자나 응용프로그래머가 접근하는 DB 정의
2. 개념 스키마
- 모든 사용자 관점을 통합한 조직 전체의 DB 기술
- 모든 응용시스템들이나 사용자들이 필요로 하는 **데이터를 통합**
3. 내부 스키마
- **물리적 장치**에서 데이터가 실제적으로 저장

> 데이터 모델링은 통합관점의 뷰를 가지고 있는 개념 스키마를 만들어가는 과정이다.

### 데이터 독립성
논리적, 물리적 독립성
1. 논리적 독립성
- 개념 스키마가 변경되어도 외부 스키마에는 영향을 미치지 않도록 지원하는 것
- 논리적 구조가 변경되어도 응용 프로그램에 영향 없음
2. 물리적 독립성
- 내부 스키마가 변경되어도 외부/개념 스키마에는 영향을 받지 않도록 지원하는 것
- 저장장치의 구조변경은 응용프로그램과 개념스키마에 영향 없음

### Mapping(사상)
논리적 사상, 물리적 사상
1. 논리적 사상(외부적/개념적 사상)
- 외부적 뷰와 개념적 뷰의 상호 관련성을 정의함
2. 물리적 사상(개념적/내부적 사상)
- 개념적 뷰와 저장된 데이터베이스의 상호관련성을 정의함

### 데이터 모델링의 3요소
어떤 것(Things), 성격(Attributes), 관계(Relationships)

### 모델링의 특징

### 데이터 모델 표기법

### ERD
- 1976년 피터첸에 의해 E-R Model이라는 표기법이 만들어졌다
- 엔터티를 어디에 배치하는가에 대한 문제는 필수사항이 아니나, 가독성 측면에서 가장 중요한 엔터티를 왼쪽 상단에 배치한다

### ERD 작업순서
1. 엔터티를 그린다
2. 엔터티를 적절하게 배치한다
3. 엔터티간 관계를 설정한다
4. 관계명을 기술한다
5. 관계의 참여도를 기술한다
6. 관계의 필수여부를 기술한다

### 좋은 데이터 모델의 요소

### 엔터티의 특징
1. 반드시 해당 업무에서 필요하고 관리하고자 하는 정보여야 한다
  - 데이터로 존재하지만 업무에서 필요로 하지 않으면 해당 업무의 엔터티로 성립될 수 없다
2. 유일한 식별자에 의해 식별이 가능해야 한다
3. **두 개 이상의** 인스턴스 집합이어야 한다
4. 반드시 속성이 있어야 한다
  - 하나의 엔터티는 두 개 이상의 속성을 가진다
5. 엔터티는 다른 엔터티와 최소 한 개 이상의 관계가 있어야 한다
  - 공통코드, 통계성 엔터티의 경우는 관계를 생략할 수 있다

### 엔터티의 분류
기본/키엔터티, 중심엔터티, 행위엔터티
1. 기본엔터티(키엔터티)
- 해당 업무에 원래 존재하는 정보
- 타 엔터티의 부모 역할
- 자신의 고유한 주식별자를 가진다
2. 중심엔터티
- 기본엔터티로부터 발생한다
- 다른 엔터티와의 관계로 많은 행위 엔터티 생성
- (ex) 계약, 사고, 주문
3. 행위엔터티
- 2개 이상의 부모엔터티로부터 발생한다
- 자주 바뀌거나 양이 증가한다
- (ex) 주문목록, 사원변경이력

### 엔터티의 명명
- 가능하면 현업업무에서 사용하는 용어를 사용한다
- 가능하면 **약어를 사용하지 않는다**
- 단수명사를 사용한다
- 모든 엔터티를 통틀어서 유일한 이름이어야 한다
- 엔터티 생성의미대로 이름을 부여한다

### 속성
속성 : **업무에서 필요로 하는 인스턴스로 관리하고자 하는 의미상 분리되지 않는 최소의 데이터 단위**
- 한 개의 엔터티는 2개 이상의 인스턴스 집합
- 한 개의 엔터티는 2개 이상의 속성을 가짐
- 한 개의 속성은 1개의 속성값을 가짐(must)

### 속성의 분류
기본속성, 설계속성, 파생속성
1. 기본속성
- 업무로부터 추출한 모든 일반적인 속성(대부분 기본속성에 포함된다)
2. 설계속성
- 업무필요에 의해 변형된 속성
- 코드성속성이 많다
- (ex) 일련번호
3. 파생속성
- 다른 속성에 영향을 받아 발생하는 속성
- 원래 속성의 값을 계산한 값이라면 파생속성에 해당한다
- 파생속성은 적게 정의하는 것이 좋다

### 속성의 도메인
속성이 가질 수 있는 값의 범위, 데이터 타입, 제약사항을 지정

### 속성의 명명
1. 해당업무에서 사용하는 이름을 부여한다
2. 서술식 속성명은 사용하지 않는다
3. 가능한 약어를 사용하지 않는다
4. 구체적으로 명명하여 데이터 모델에서 유일성을 확보한다
> 직원 엔터티와 고객 엔터티에 이름이라는 속성이 있다면 동일한 속석명보단 다른 속성명을 사용하는 것이 좋다

### 관계
- 엔터티의 인스턴스 사이의 논리적인 연관성으로서 존재의 형태로서나 행위로서 서로에게 연관성이 부여된 상태
- 관계 페어링의 집합
> 패어링 : 엔터티 안에 인스턴스가 개별적으로 관계를 가지는 것

### UML(통합모델링언어)에서의 관계
연관관계, 의존관계
1. 연관관계(실선) : 항상 이용되는 관계 (ex) 소속
2. 의존관계(점선) : 상대 행위에 의해 발생하는 관계 (ex) 주문

### 관계의 표기법
관계명, 관계차수, 선택성(선택사양)
1. 관계명 : 관계의 이름
2. 관계차수 : 1:1, 1:m, n:m
3. 선택사양 : 필수관계, 선택관계

### 관계 체크사항
- 두 개의 엔터티 사이에 관심 있는 연관규칙이 존재하는가?
- 두 개의 엔터티 사이에 정보의 조합이 발생되는가?
- 업무기술서, 상표에 관계연결을 가능하게 하는 **동사**가 있는가?
- 업무기술서, 상표에 관계연결에 대한 규칙이 서술되어 있는가?

### 식별자
- 엔터티 내에서 인스턴스를 구분하는 구분자
- 식별자는 논리적 데이터 모델링 단계에서 사용하고, Key는 물리적 데이터 모델링 단계에서 사용한다

### 식별자의 특징
유일성, 최소성, 불변성, 존재성
1. 유일성 : 주식별자에 의해 모든 인스턴스들이 유일하게 구분된다
2. 최소성 : 주식별자를 구분하는 속성의 수는 유일성을 만족하는 최소의 수가 되어야 한다
3. 불변성 : 지정된 주식별자의 값은 자주 변하지 않아야 한다
  - 아예 고정되어야 하는 것은 아님
  - 값이 변하면 이전 값은 지워짐
4. 존재성 : 주식별자가 지정되면 반드시 값이 들어와야 한다(Not Null)

### 식별자 분류
1. 엔터티 내에서 대표성을 가지는가?(대표성 여부) → 주식별자, 보조식별자
- 주식별자 : 엔터티 내에서 각 어커런스를 구분할 수 있는 구분자이며, 타 엔터티와 참조관계로 연결될 수 있다
- 보조식별자 : 구분자이기는 하나 대표성이 없고 참조관계로 연결될 수 없다
2. 엔터티 내에서 스스로 생성되었는가?(스스로 생성 여부) → 내부식별자, 외부식별자(FK)
- 내부식별자 : 스스로 생성된 식별자이다
- 외부식별자 : 타 엔터티로부터 받아온 식별자이다
3. 단일 속성으로 식별이 되는가?(속성의 수) → 단일식별자, 복합식별자
- 단일식별자 : 하나의 속성으로 구성된 식별자이다
- 복합식별자 : 2개 이상의 속성으로 구성된 식별자이다
4. 원래부터 업무적으로 의미가 있었는가?(대체 여부) → 본질식별자, 인조식별자
- 본질식별자 : 업무에 의해 만들어진 식별자이다
- 인조식별자 : 인위적으로 만든 식별자이다 (ex) 일련번호 등

### 식별자 관계
주식별자, 비식별자
1. 주식별자 : 자식의 주식별자로 부모의 주식별자 상속
- 부모로부터 받은 식별자를 자식 엔터티의 주식별자로 이용하는 경우
- 강한 연결관계(실선 표기)
- 식별자 관계로만 설정 시 주식별자 증가로 오류 유발
2. 비식별자 : 부모 속성을 자식의 일반 속성으로 사용
- 비식별자로 설정하는 경우
  - 부모 없는 자식이 생성될 수 있는 경우
  - 부모와 자식의 생명주기가 다른 경우(별도로 소멸되어야 하는 경우)
  - 여러개의 엔터티가 하나의 엔터티로 통합되어 표현되었으며, 각각의 엔터티가 별도의 관계를 가진 경우
  - 자식엔터티에 별도의 주식별자를 생성하는 것이 더 유리한 경우
  - SQL 문장이 길어져 복잡성 증가되는 것을 방지(가장 약한 원인이며, 해당 이유로만 비식별자를 설정하는 것은 지양한다)
- 약한 연결관계(점선 표기)
- 비식별자 관계로만 설정 시 부모 엔터티와 조인하여 성능 저하

---
## 2장 데이터 모델과 성능

### 성능 데이터 모델링이란?
- 데이터베이스 성능 향상을 목적으로 설계단계의 데이터 모델링 때부터 성능과 관련된 사항이 데이터 모델링에 반영될 수 있도록 한다(정규화, 반정규화, 테이블통합, 테이블분할, 조인구조, PK, FK 등)
- 분석/설계 단계에서 데이터 모델에 성능을 고려한 데이터 모델링을 수행할 경우 성능저하에 따른 재업무 비용을 최소화할 수 있다
- 데이터의 증가가 빠를수록 성능저하에 따른 성능개선비용은 기하급수적으로 증가한다

### 성능 데이터 모델링 고려사항 순서
1. 데이터 모델링을 할 때 정규화를 정확하게 수행한다
2. 데이터베이스 용량산정을 수행한다
3. 데이터베이스에 발생되는 트랜잭션의 유형을 파악한다
4. 용량과 트랜잭션의 유형에 따라 반정규화를 수행한다
5. 이력모델의 조정, PK/FK의 조정, 슈퍼타입/서브타입 조정 등을 수행한다
6. 성능관점에서 데이터모델을 검증한다

### 함수적 종속성
데이터들이 어떤 기준값에 의해 종속되는 현상

### (-) 정규화
반복적인 데이터를 분리하고 각 데이터가 종속된 테이블에 적절하게 배치되도록 하는 것

1. 1차 정규화 : 같은 성격, 내용 컬럼이 연속될 때 컬럼 제거, 테이블 생성
2. 2차 정규화 : PK 복합키 구성일 때 부분적 함수 종속 관계 테이블 분리
3. 3차 정규화 : PK가 아닌 일반 컬럼에 의존하는 컬럼 분리

### (+) 반정규화
정규화된 엔터티, 속성, 관계에 대해 시스템의 성능향상 및 개발과 운영의 단순화를 위해 중복, 통합, 분리 등을 수행하는 데이터 모델링의 기법
- 조회 시 디스크 I/O가 많거나 경로가 멀어 조인에 의한 성능 저하를 막기 위해 수행
- 일반적으로 정규화시 입력/수정/삭제 성능이 향상되며 반정규화시 **조인 성능이 향상**된다

### 반정규화 절차
1. 반정규화 대상 조사(범위처리빈도수, 범위, 통계성)
- 자주 사용되는 테이블에 접근하는 프로세스의 수가 많고 항상 일정한 범위만을 조회하는 경우
- 테이블에 대량의 데이터가 있고 대량의 데이터 범위를 자주 처리하는 경우에 처리범위를 일정하게 줄이지 않으면 성능을 보장할 수 없는 경우
- 통계성 프로세스에 의해 통계 정보를 필요로 할 때 별도의 통계테이블을 생성한다
- 테이블에 지나치게 많은 조인이 걸려 데이터를 조회하는 작업이 기술적으로 어려울 경우
2. 다른 방법유도 검토(뷰, 클러스터링, 인덱스 조정)
- VIEW 사용 : 지나치게 많은 조인이 걸려 데이터를 조회하는 작업이 기술적으로 어려울 경우 VIEW를 사용한다
- 클러스터링 : 대량의 데이터처리나 부분처리에 의해 성능이 저하되는 경우 클러스터링을 적용하거나 인덱스를 조정한다(조회가 대부분인 경우에는 클러스터링 적용)
- 파티셔닝 : 대량의 데이터는 PK의 성격에 따라 부분적인 테이블로 분리할 수 있다 파티셔닝 키를 이용해 물리적 저장공간을 분리한다
- 캐시 : 응용 애플리케이션에서 로직을 구사하는 방법을 변경함으로써 성능을 향상시킬 수 있다
3. 반정규화 적용
- 테이블 반정규화
  - 테이블 병합(1:1, 1:M, 슈퍼/서브타입)
    - 1:1 관계를 통합하여 성능향상
    - 1:M 관계를 통합하여 성능향상
    - 슈퍼/서브 관계를 통합하여 성능향상
  - 테이블분할(수직분할, 수평분할)
    - 수직분할 : 칼럼단위 테이블을 디스크 I/O를 분산처리하기 위해 테이블을 1:1로 분리하여 성능향상
    - 수평분할 : 로우단위로 집중 발생되는 트랜잭션을 분석하여 디스크 I/O 및 데이터 접근의 효율성을 높여 성능을 향상하기 위해 로우단위로 테이블 분할
  - 테이블추가
    - 중복 : 다른 업무이거나 서버가 다른 경우 동일한 테이블구조를 중복하여 원격조인을 제거하여 성능향상
    - 통계 : SUM, AVG 등을 미리 수행하여 계산해 둠으로써 조회 시 성능을 향상
    - 이력 : 이력테이블 중에서 마스터 테이블에 존재하는 레코드를 중복하여 이력테이블에 존재시켜 성능향상
    - 부분 : 하나의 테이블의 전체 칼럼 중 자주 이용하는 집중화된 칼럼들이 있을 때 디스크 I/O를 줄이기 위해 해당 칼럼들을 모아놓은 별도의 반정규화된 테이블을 생성
- 칼럼 반정규화
  - 중복칼럼 추가 : 조인에 의해 처리할 때 성능저하를 예방하기 위해 중복된 컬럼을 위치시킴
  - 파생컬럼 추가 : 트랜잭션이 처리되는 시점에 계산에 의해 발생되는 성능저하를 예방하기 위해 미리 값을 계산하여 컬럼에 보관
  - 이력테이블 컬럼 추가 : 대랴의 이력데이터를 처리할 때 불특정 조회나 최근 값 조회 시 나타날 수 있는 성능저하를 예방하기 위해 기능성 컬럼을 추가 (ex) 최근값 여부, 시작과 종료일자 등
  - 응용시스템 오작동을 위한 컬럼 추가 : 업무적으로는 의미가 없지만 사용자의 실수로 원래값으로 복구하기 원하는 경우 이전 데이터를 임시적으로 중복하여 보관하는 기법
  - PK에 의한 컬럼 추가 : 단일 PK 안에서 특정 값을 별도로 조회하는 경우 성능 저하가 발생할 수 있어 일반속성으로 추가
- 관계 반정규화
  - 무결성 유지
  - 중복관계 추가 : 데이터를 처리하기 위한 여러 경로를 거쳐 조인이 가능하지만 이때 발생할 수 있는 성능저하를 위해 추가적인 관계를 맺는 방법

### 로우 체이닝, 로우 마이그레이션
1. 로우 체이닝 : 로우의 길이가 너무 길어서 데이터 블록 하나에 데이터가 모두 저장되지 않고 두 개 이상의 블록에 걸쳐 하나의 로우가 저장되어 있는 형태
2. 로우 마이그레이션 : 데이터블록에서 수정이 발생하면 수정된 데이터를 해당 데이터 블록에서 저장하지 못하고 다른 블록의 빈 공간을 찾아 저장하는 방식
- 로우 체이닝과 로우 마이그레이션이 발생하여 많은 블록에 데이터가 저장되면 데이터베이스 메모리에서 디스크 I/O가 발생할 때 많은 I/O가 발생하게 되어 성능저하가 발생할 수 있다
- 트랜잭션을 분석하여 적합하게 1:1 관계로 분리함으로써 성능향상하는 것이 좋다

### 파티셔닝(PK에 의한 테이블 분할)
1. RANGE PARTITION 
2. LIST PARTITION
3. HASH PARTITION

### 테이블에 대한 수평/수직 분할의 절차
1. 데이터 모델링을 완성한다
2. 데이터베이스 용량산정을 한다
3. 대량 데이터가 처리되는 테이블에 대해 트랜잭션 처리 패턴을 분석한다
4. 칼럼 단위로 집중화된 처리가 발생하는지, 로우 단위로 집중화된 처리가 발생하는지 분석하여 테이블 분리를 검토한다
  - 컬럼 多 : 1:1 분리
  - 데이터 多 : 파티셔닝

### 슈퍼/서브 타입 모델
- 업무를 구성하는 데이터를 공통과 차이점의 특징을 고려하여 효과적 표현
- 논리적 모델
1. 슈퍼 타입 : 공통 부분
2. 서브 타입 : 공통으로부터 상속받아 다른 엔터티와 차이가 있는 속성

### 인덱스 특성을 고려한 PK/FK 데이터베이스 성능향상
- 여러개의 속성이 하나의 인덱스로 구성되어 있다면 앞쪽에 위치한 속성값이 비교자로 있어야 효율이 좋음
- 가급적 `=` 최소한 `BETWEEN`, `<>`

### 분산 데이터베이스
- 여러 곳으로 분산되어 있는 데이터베이스를 하나의 가상 시스템으로 사용할 수 있도록 한 데이터베이스를 말한다
- 논리적으로 동일한 시스템이다
- 컴퓨터 네트워크를 통해 물리적으로 분산되어 있는 데이터집합이다

### 분산 데이터베이스를 만족하기 위한 6가지 투명성
1. 분할 투명성(단편화) : 하나의 논리적인 Relation이 여러 단편으로 분할되어 각 사본이 여러 site에 저장
2. 위치 투명성 : 사용하려는 데이터의 저장 장소 명시 불필요, 위치정보가 시스템 카탈로그에 유지
3. 지역사상 투명성 : 지역 DBMS와 물리적 데이터베이스 사이의 Mapping 보장
4. 중복 투명성 : DB 객체가 여러 site에 중복되어 있는지 알 필요가 없는 성질
5. 장애 투명성 : 구성요소의 장애에 무관한 트랜잭션의 원자성 유지
6. 병행 투명성 : 다수 트랜잭션 동시 수행시 결과의 일관성 유지

### 분산 데이터베이스 장단점
- 장점 : 빠른 응답속도, 비용절감, 각 지역 사용자 요구 수용
- 단점 : 오류의 잠재성 증대, 설계 관리의 복잡성, 불규칙한 응답 속도, 통제의 어려움, 데이터 무결성 위협

### 분산 데이터베이스 적용 기법
1. 테이블 위치 분산
- 설계된 테이블을 본사와 지사단위로 분산
- 위치별 데이터베이스 문서 필요
2. 테이블 분할 분산
- 수평분할 : 로우 단위로 분리, 지사별로 다를 때, 중복이 없다
- 수직분할 : 칼럼 단위로 분리, 각 테이블에 동일 pk가 있어야 한다
3. 테이블 복제 분산
동일한 테이블에 다른 지역이나 서버에서 동시에 생성하여 관리하는 유형
- 부분복제 : 마스터 데이터베이스에서 테이블의 일부 내용만 다른 지역이나 서버에 위치
- 광역복제 : 마스터 데이터베이스 테이블의 내용을 각 지역이나 서버에 존재
4. 테이블 요약 분산
지역 간 또는 서버 간 데이터가 비슷하지만 서로 다른 유형으로 존재하는 경우
- 분석요약 : 동일한 테이블 구조를 가지고 있으면서 분산되어 있는 동일한 내용의 데이터를 이용하여 통합된 데이터를 산출하는 방식
- 통합요약 : 분산되어 있는 다른 내용의 데이터를 이용하여 통합된 데이터를 산출하는 방식

### 분산 데이터베이스 설계를 고려해야 하는 경우
1. 성능이 중요한 사이트
2. 공통코드, 기준정보, 마스터 데이터의 성능향상
3. 실시간 동기화가 요구되지 않는 경우 - Near RealTime 특징
4. 특정 서버에 부하가 집중되어 부하를 분산해야 하는 경우
5. 백업 사이트 

---
# 2과목
## 1장 SQL 기본
## 2장

### 집합 연산자
- 두 개 이상의 테이블에서 조인을 사용하지 않고 연관된 데이터들을 조회
- SELECT절의 컬럼 수가 동일하고, SELECT절의 동일 위치에 존재하는 컬럼의 데이터 타입이 같아야 함
- ORDER BY는 최종 결과에 대한 정렬 처리이므로 가장 마지막 줄에 한번만 기술

### 집합 연산자 종류
UNION, UNION ALL, INTERSECT, EXCEPT(오라클은 MINUS)
- UNION ALL을 제외한 집합 연산자는 중복행을 제거한다

